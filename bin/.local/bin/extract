#!/usr/bin/env bash

###############################################################################
# Extract archive(s)
# Requirements: unzip, tar, bunzip2, gunzip, 7z, uncompress, zipinfo
###############################################################################

ensure_installed() {
    if ! command -v "$1" > /dev/null; then
        echo "Error: $1 not found"
        exit 1
    fi
}

raise() {
    echo "Error: $1"
    exit 1
}

remove_archive() {
    if [[ "$KEEP_ARCHIVES" != "true" ]]; then
        [[ "$VERBOSE" != "true" ]] || echo -n "Removing archive '$1'... "
        rm -f "$1"
        [[ "$VERBOSE" != "true" ]] || echo "Done"
    fi
}

extract_zip() {
    ensure_installed unzip

    local name
    local need_new_dir='false'
    name=$(basename -- "$1")
    if [[ -n "$EXTRACT_TO" ]]; then
        # use custom directory name
        name="$EXTRACT_TO"
        need_new_dir='true'
    else
        # remove file extension
        name="${name%.*}"
    fi

    if [[ -z "$EXTRACT_TO" ]]; then
        # don't create a new directory if there's one directory containing
        # every other file in the archive
        local -a zip_items
        while IFS= read -r line; do
            zip_items+=("$line")
        done < <(zipinfo "$1" \* 2> /dev/null | awk '{print $NF}')

        # check if zipinfo failed or there were no files
        if [[ ${#zip_items[@]} -ne 0 ]]; then
            for element in "${zip_items[@]}"; do
                if [[ "$element" != "${zip_items[0]}"* ]]; then
                    # $element does not start with first item name
                    readonly need_new_dir='true'
                    break
                fi
            done
        fi
    fi

    if [[ "$need_new_dir" == "true" ]]; then
        [[ "$VERBOSE" != "true" ]] || echo -n "Extracting files from $1 into $name... "
        unzip "$1" -d "$name" > /dev/null
        [[ "$VERBOSE" != "true" ]] || echo "Done"
    else
        [[ "$VERBOSE" != "true" ]] || echo -n "Extracting files from $1... "
        unzip "$1" > /dev/null
        [[ "$VERBOSE" != "true" ]] || echo "Done"
    fi

    remove_archive "$1"
}

extract_with_7z() {
    name=$(basename -- "$1")
    name="${name%.*}"

    ensure_installed 7z

    [[ "$VERBOSE" != "true" ]] || echo -n "Extracting files from $1 into $name... "
    7z x "$1" -o"$name" > /dev/null
    remove_archive "$1"
    [[ "$VERBOSE" != "true" ]] || echo "Done"
}

show_help() {
    echo "Usage: extract [OPTIONS] <ARCHIVES...>"
    echo "Extracts archive(s). In case of zip files, smartly detect if a new directory to extract the content to is needed."
    echo
    echo "Options:"
    echo "  -h, --help           Display this help message."
    echo "  -s, --silent         Disable verbose output."
    echo "  -k, --keep           Keep the archive(s) after extraction."
    echo "  -t, --to <name>      Extract to a specific directory. Only works with one archive."
    exit 0
}

extract_archive() {
    if [[ ! -f $1 ]]; then
        raise "'$1' does not exist"
    fi

    case $1 in
        *.tar.bz2) tar xjf "$1" ;;
        *.tar.gz) tar xzf "$1" ;;
        *.tar.xz) tar xJf "$1" ;;
        *.bz2) bunzip2 "$1" ;;
        *.rar) extract_with_7z "$1" ;;
        *.gz) gunzip "$1" ;;
        *.tar) tar xf "$1" ;;
        *.tbz2) tar xjf "$1" ;;
        *.tgz) tar xzf "$1" ;;
        *.zip) extract_zip "$1" ;;
        *.Z) uncompress "$1" ;;
        *.7z) extract_with_7z "$1" ;;
        *) raise "'$1' cannot be extracted with this program" ;;
    esac
}

main() {
    VERBOSE='true'
    KEEP_ARCHIVES='false'
    EXTRACT_TO=''
    ARCHIVES=()

    # TODO: add options
    # -f to skip zipinfo part for too large archives
    while true; do
        case $1 in
            -h | --help) show_help ;;
            -s | --silent)
                readonly VERBOSE='false'
                shift
                ;;
            -k | --keep)
                readonly KEEP_ARCHIVES='true'
                shift
                ;;
            -t | --to)
                if [[ -z "$2" ]]; then
                    raise "Option '$1' requires a name"
                fi
                readonly EXTRACT_TO="$2"
                shift 2
                ;;
            -*)
                echo "Error: Unknown option: '$1'" >&2
                show_help
                ;;
            *)
                if [[ -z "$1" ]]; then
                    break
                fi
                ARCHIVES+=("$1")
                shift
                ;;
        esac
    done

    if ((${#ARCHIVES[@]} == 0)); then
        raise "Need an archive to extract"
    fi

    if [[ -n "$EXTRACT_TO" ]]; then
        if ((${#ARCHIVES[@]} != 1)); then
            raise "Multiple archives with destination directory are not supported"
        fi
    fi

    for i in "${ARCHIVES[@]}"; do
        extract_archive "$i"
    done
}

main "$@"
